# Phases 5-7 Implementation Plan: Club Profiles, UX Polish, Advanced Features

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Complete the remaining UI features from the data model & UX overhaul â€” smart club comparison, date range filtering, session notes, trajectory visualization, shot navigator, and goal tracking.

**Architecture:** Each task adds a self-contained component or enhancement. Date range filtering is a cross-cutting filter applied to existing data access. Trajectory and goal tracking are new Plotly-based components following the existing `render_*()` pattern. All new components are stateless (data in, render out).

**Tech Stack:** Streamlit, Plotly, pandas, SQLite (golf_db.py)

---

## Phase 5: Club Profiles Enhancement

### Task 1: Smart Adjacent Club Suggestions

**Files:**
- Modify: `utils/bag_config.py`
- Modify: `pages/2_ğŸŒï¸_Club_Profiles.py:106-116`
- Test: `tests/unit/test_bag_config.py`

**Context:** When viewing a club profile, the radar comparison currently defaults to the first 2 clubs in the list. It should suggest adjacent clubs from the bag order (e.g., viewing 7 Iron â†’ suggest 6 Iron + 8 Iron).

**Step 1: Write the failing test**

In `tests/unit/test_bag_config.py`, add:

```python
class TestAdjacentClubs(unittest.TestCase):
    def test_middle_club_returns_neighbors(self):
        from utils.bag_config import get_adjacent_clubs
        result = get_adjacent_clubs('7 Iron')
        self.assertEqual(result, ['6 Iron', '8 Iron'])

    def test_first_club_returns_next_only(self):
        from utils.bag_config import get_adjacent_clubs
        result = get_adjacent_clubs('Driver')
        self.assertEqual(result, ['3 Wood (Cobra)'])

    def test_last_club_returns_prev_only(self):
        from utils.bag_config import get_adjacent_clubs
        result = get_adjacent_clubs('Putter')
        self.assertEqual(result, ['LW'])

    def test_unknown_club_returns_empty(self):
        from utils.bag_config import get_adjacent_clubs
        result = get_adjacent_clubs('Unknown Club')
        self.assertEqual(result, [])
```

**Step 2: Run test to verify it fails**

Run: `python -m unittest tests.unit.test_bag_config -v -k TestAdjacentClubs`
Expected: FAIL with "cannot import name 'get_adjacent_clubs'"

**Step 3: Write minimal implementation**

In `utils/bag_config.py`, add after `get_special_categories()`:

```python
def get_adjacent_clubs(club_name: str) -> List[str]:
    """Return bag-adjacent clubs (prev, next) for comparison suggestions."""
    order = get_bag_order()
    try:
        idx = order.index(club_name)
    except ValueError:
        return []
    adjacent = []
    if idx > 0:
        adjacent.append(order[idx - 1])
    if idx < len(order) - 1:
        adjacent.append(order[idx + 1])
    return adjacent
```

**Step 4: Run test to verify it passes**

Run: `python -m unittest tests.unit.test_bag_config -v -k TestAdjacentClubs`
Expected: PASS (4 tests)

**Step 5: Wire into Club Profiles page**

In `pages/2_ğŸŒï¸_Club_Profiles.py`, change the imports to add `get_adjacent_clubs`:

```python
from utils.bag_config import get_club_sort_key, get_adjacent_clubs
```

Replace lines 106-116 (the radar comparison section):

```python
# â”€â”€â”€ Club Comparison Radar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
st.markdown("#### Compare with Other Clubs")
other_clubs = [c for c in clubs if c != selected_club]
suggested = [c for c in get_adjacent_clubs(selected_club) if c in other_clubs]
default_compare = suggested[:2] if suggested else other_clubs[:2]
compare_clubs = st.multiselect(
    "Compare with:",
    other_clubs,
    default=default_compare,
    max_selections=3,
    key="radar_compare_clubs",
)
render_radar_chart(all_shots, clubs=[selected_club] + compare_clubs)
```

**Step 6: Run full test suite**

Run: `python -m unittest discover -s tests`
Expected: All pass

**Step 7: Commit**

```bash
git add utils/bag_config.py pages/2_ğŸŒï¸_Club_Profiles.py tests/unit/test_bag_config.py
git commit -m "feat: smart adjacent club suggestions in Club Profiles radar"
```

---

## Phase 6: UX Polish

### Task 2: Date Range Filter Component

**Files:**
- Create: `components/date_range_filter.py`
- Modify: `components/__init__.py`
- Test: `tests/unit/test_date_range_filter.py`

**Context:** `utils/session_state.py` has `get_date_range()`/`set_date_range()` infrastructure. We need a reusable Streamlit component that renders the filter and returns the selected range. Pages will use this to filter their DataFrames.

**Step 1: Write the failing test**

Create `tests/unit/test_date_range_filter.py`:

```python
import unittest
from datetime import date

class TestFilterShotsbyDateRange(unittest.TestCase):
    """Test the pure filtering logic (no Streamlit dependency)."""

    def test_filter_with_both_dates(self):
        import pandas as pd
        from components.date_range_filter import filter_by_date_range
        df = pd.DataFrame({
            'session_date': ['2026-01-01', '2026-01-15', '2026-02-01', '2026-02-15'],
            'carry': [200, 210, 220, 230],
        })
        result = filter_by_date_range(df, date(2026, 1, 10), date(2026, 2, 5))
        self.assertEqual(len(result), 2)
        self.assertListEqual(result['carry'].tolist(), [210, 220])

    def test_filter_with_start_only(self):
        import pandas as pd
        from components.date_range_filter import filter_by_date_range
        df = pd.DataFrame({
            'session_date': ['2026-01-01', '2026-02-01'],
            'carry': [200, 220],
        })
        result = filter_by_date_range(df, date(2026, 1, 15), None)
        self.assertEqual(len(result), 1)

    def test_filter_with_no_dates_returns_all(self):
        import pandas as pd
        from components.date_range_filter import filter_by_date_range
        df = pd.DataFrame({
            'session_date': ['2026-01-01', '2026-02-01'],
            'carry': [200, 220],
        })
        result = filter_by_date_range(df, None, None)
        self.assertEqual(len(result), 2)

    def test_filter_empty_dataframe(self):
        import pandas as pd
        from components.date_range_filter import filter_by_date_range
        df = pd.DataFrame(columns=['session_date', 'carry'])
        result = filter_by_date_range(df, date(2026, 1, 1), date(2026, 2, 1))
        self.assertTrue(result.empty)
```

**Step 2: Run test to verify it fails**

Run: `python -m unittest tests.unit.test_date_range_filter -v`
Expected: FAIL (module not found)

**Step 3: Write the component**

Create `components/date_range_filter.py`:

```python
"""
Date range filter component.

Renders preset buttons (This Week, Last Month, etc.) and a custom date range picker.
Pure filtering function is separate for testability.
"""
import streamlit as st
import pandas as pd
from datetime import date, timedelta
from typing import Optional, Tuple


def filter_by_date_range(
    df: pd.DataFrame,
    start: Optional[date],
    end: Optional[date],
) -> pd.DataFrame:
    """Filter DataFrame by session_date range.

    Args:
        df: DataFrame with 'session_date' column (YYYY-MM-DD strings).
        start: Inclusive start date, or None for no lower bound.
        end: Inclusive end date, or None for no upper bound.

    Returns:
        Filtered DataFrame.
    """
    if df.empty or 'session_date' not in df.columns:
        return df
    if start is None and end is None:
        return df

    dates = pd.to_datetime(df['session_date'], errors='coerce').dt.date
    mask = pd.Series(True, index=df.index)
    if start is not None:
        mask &= dates >= start
    if end is not None:
        mask &= dates <= end
    return df[mask].copy()


def render_date_range_filter(key_prefix: str = "date_filter") -> Tuple[Optional[date], Optional[date]]:
    """Render date range filter UI and return selected range.

    Args:
        key_prefix: Unique key prefix for Streamlit widgets.

    Returns:
        (start_date, end_date) tuple. Either may be None.
    """
    today = date.today()

    presets = {
        "All Time": (None, None),
        "This Week": (today - timedelta(days=today.weekday()), today),
        "Last 2 Weeks": (today - timedelta(days=14), today),
        "Last Month": (today - timedelta(days=30), today),
        "Last 3 Months": (today - timedelta(days=90), today),
    }

    cols = st.columns(len(presets) + 1)
    selected_preset = None

    for i, (label, _) in enumerate(presets.items()):
        with cols[i]:
            if st.button(label, key=f"{key_prefix}_{label}", use_container_width=True):
                selected_preset = label

    with cols[-1]:
        custom = st.button("Custom", key=f"{key_prefix}_custom", use_container_width=True)

    # Use session state to persist selection
    state_key = f"{key_prefix}_selection"
    if selected_preset:
        st.session_state[state_key] = selected_preset
    elif custom:
        st.session_state[state_key] = "Custom"

    current = st.session_state.get(state_key, "All Time")

    if current == "Custom":
        c1, c2 = st.columns(2)
        with c1:
            start = st.date_input("From", value=today - timedelta(days=30), key=f"{key_prefix}_start")
        with c2:
            end = st.date_input("To", value=today, key=f"{key_prefix}_end")
        return (start, end)

    return presets.get(current, (None, None))
```

**Step 4: Run tests to verify they pass**

Run: `python -m unittest tests.unit.test_date_range_filter -v`
Expected: PASS (4 tests)

**Step 5: Register in components/__init__.py**

Add to `components/__init__.py` imports:

```python
from components.date_range_filter import render_date_range_filter, filter_by_date_range
```

**Step 6: Commit**

```bash
git add components/date_range_filter.py tests/unit/test_date_range_filter.py components/__init__.py
git commit -m "feat: add date range filter component with presets"
```

---

### Task 3: Wire Date Range Filter into Dashboard and Club Profiles

**Files:**
- Modify: `pages/1_ğŸ“Š_Dashboard.py`
- Modify: `pages/2_ğŸŒï¸_Club_Profiles.py`

**Context:** Add the date range filter below the page title on Dashboard and Club Profiles. Apply filtering before passing data to components.

**Step 1: Add filter to Dashboard**

In `pages/1_ğŸ“Š_Dashboard.py`, add import:

```python
from components.date_range_filter import render_date_range_filter, filter_by_date_range
```

After `st.title("Dashboard")` / `st.caption(...)` (line 49), add:

```python
# Date range filter
start_date, end_date = render_date_range_filter(key_prefix="dash_date")
if start_date or end_date:
    df = filter_by_date_range(df, start_date, end_date)
    if df.empty:
        st.info("No shots in selected date range.")
        st.stop()
```

**Step 2: Add filter to Club Profiles**

In `pages/2_ğŸŒï¸_Club_Profiles.py`, add import:

```python
from components.date_range_filter import render_date_range_filter, filter_by_date_range
```

After `st.caption("Deep dive into each club's performance story")` (line 32), add:

```python
# Date range filter
start_date, end_date = render_date_range_filter(key_prefix="club_date")
if start_date or end_date:
    all_shots = filter_by_date_range(all_shots, start_date, end_date)
    if all_shots.empty:
        st.info("No shots in selected date range.")
        st.stop()
```

**Step 3: Verify manually**

Run: `streamlit run app.py`
- Navigate to Dashboard â†’ date filter buttons should appear
- Navigate to Club Profiles â†’ date filter buttons should appear
- Selecting a range should filter the data shown below

**Step 4: Run full test suite**

Run: `python -m unittest discover -s tests`
Expected: All pass

**Step 5: Commit**

```bash
git add pages/1_ğŸ“Š_Dashboard.py pages/2_ğŸŒï¸_Club_Profiles.py
git commit -m "feat: wire date range filter into Dashboard and Club Profiles"
```

---

### Task 4: Session Notes

**Files:**
- Modify: `golf_db.py` (ALLOWED_UPDATE_FIELDS + schema)
- Modify: `pages/1_ğŸ“Š_Dashboard.py` (shots tab detail pane)
- Modify: `components/journal_card.py` (display note snippet)
- Test: `tests/test_golf_db.py`

**Context:** Add a `session_notes` TEXT column to `shots` table. Notes are per-session (all shots in a session share the same note). Display in journal cards, editable in Dashboard shot detail.

**Step 1: Write the failing test**

In `tests/test_golf_db.py`, add:

```python
class TestSessionNotes(unittest.TestCase):
    def setUp(self):
        import tempfile
        self.db_path = tempfile.mktemp(suffix='.db')
        self._orig = golf_db.SQLITE_DB_PATH
        self._orig_supa = golf_db.supabase
        golf_db.SQLITE_DB_PATH = self.db_path
        golf_db.supabase = None
        golf_db.init_db()

    def tearDown(self):
        golf_db.SQLITE_DB_PATH = self._orig
        golf_db.supabase = self._orig_supa
        import os
        for f in [self.db_path] + [self.db_path + ext for ext in ['-wal', '-shm']]:
            if os.path.exists(f):
                os.unlink(f)

    def test_session_notes_column_exists(self):
        import sqlite3
        conn = sqlite3.connect(self.db_path)
        c = conn.cursor()
        c.execute("PRAGMA table_info(shots)")
        columns = {row[1] for row in c.fetchall()}
        self.assertIn('session_notes', columns)
        conn.close()

    def test_session_notes_in_allowed_fields(self):
        self.assertIn('session_notes', golf_db.ALLOWED_UPDATE_FIELDS)
```

**Step 2: Run test to verify it fails**

Run: `python -m unittest tests.test_golf_db -v -k TestSessionNotes`
Expected: FAIL

**Step 3: Implement**

In `golf_db.py`, add to `required_columns` dict (~line 167):

```python
'session_notes': 'TEXT',
```

Add to `ALLOWED_UPDATE_FIELDS` (~line 1081):

```python
'session_notes',
```

**Step 4: Run tests**

Run: `python -m unittest tests.test_golf_db -v -k TestSessionNotes`
Expected: PASS

**Step 5: Add notes display to journal card**

In `components/journal_card.py`, in the card rendering section, after the existing metric display, add a notes snippet if present:

```python
# Show session notes snippet if present
notes = session.get('session_notes', '')
if notes:
    truncated = notes[:80] + '...' if len(notes) > 80 else notes
    st.caption(f"ğŸ“ {truncated}")
```

**Step 6: Add notes editor to Dashboard shot detail**

In `pages/1_ğŸ“Š_Dashboard.py`, in the `tab_shots` section, after the shot detail metrics (around line 173), add a session notes editor:

```python
st.divider()
st.markdown("**Session Notes**")
current_session = selected_session_id
note_key = f"note_{current_session}"
existing_note = df.iloc[0].get('session_notes', '') if not df.empty else ''
new_note = st.text_area(
    "Notes for this session",
    value=existing_note or '',
    placeholder="What were you working on? How did it feel?",
    key=note_key,
    label_visibility="collapsed",
)
if st.button("Save Note", key=f"save_{note_key}"):
    shot_ids = df['shot_id'].tolist()
    golf_db.update_shot_metadata(shot_ids, 'session_notes', new_note)
    st.success("Note saved!")
    st.rerun()
```

**Step 7: Run full test suite**

Run: `python -m unittest discover -s tests`
Expected: All pass

**Step 8: Commit**

```bash
git add golf_db.py pages/1_ğŸ“Š_Dashboard.py components/journal_card.py tests/test_golf_db.py
git commit -m "feat: add session notes (schema + journal display + Dashboard editor)"
```

---

## Phase 7: Advanced Features

### Task 5: Trajectory Visualization Component

**Files:**
- Create: `components/trajectory_view.py`
- Modify: `components/__init__.py`
- Modify: `pages/1_ğŸ“Š_Dashboard.py` (add to shots tab)
- Test: `tests/unit/test_trajectory_view.py`

**Context:** 2D side-view trajectory using carry distance, apex height, launch angle, and descent angle. Uses a parabolic approximation â€” not physics simulation, just visualization.

**Step 1: Write the failing test**

Create `tests/unit/test_trajectory_view.py`:

```python
import unittest

class TestTrajectoryData(unittest.TestCase):
    def test_compute_trajectory_points(self):
        from components.trajectory_view import compute_trajectory_points
        points = compute_trajectory_points(
            carry=200, apex=30, launch_angle=12, descent_angle=40
        )
        # Should return list of (x, y) tuples
        self.assertIsInstance(points, list)
        self.assertTrue(len(points) >= 10)
        # First point at origin
        self.assertAlmostEqual(points[0][0], 0, places=1)
        self.assertAlmostEqual(points[0][1], 0, places=1)
        # Last point at carry distance, near ground
        self.assertAlmostEqual(points[-1][0], 200, places=0)
        self.assertAlmostEqual(points[-1][1], 0, delta=2)
        # Max height near apex
        max_y = max(p[1] for p in points)
        self.assertAlmostEqual(max_y, 30, delta=5)

    def test_compute_trajectory_missing_data_returns_empty(self):
        from components.trajectory_view import compute_trajectory_points
        points = compute_trajectory_points(carry=None, apex=None, launch_angle=None, descent_angle=None)
        self.assertEqual(points, [])
```

**Step 2: Run test to verify it fails**

Run: `python -m unittest tests.unit.test_trajectory_view -v`
Expected: FAIL (module not found)

**Step 3: Write the component**

Create `components/trajectory_view.py`:

```python
"""
2D trajectory visualization â€” side view of ball flight.

Uses carry distance, apex height, launch angle, and descent angle to
approximate the trajectory arc. Not a physics sim â€” just a visual.
"""
import streamlit as st
import plotly.graph_objects as go
import pandas as pd
import numpy as np
import math
from typing import List, Tuple, Optional


def compute_trajectory_points(
    carry: Optional[float],
    apex: Optional[float],
    launch_angle: Optional[float],
    descent_angle: Optional[float],
    num_points: int = 50,
) -> List[Tuple[float, float]]:
    """Compute (x, y) trajectory points for a shot.

    Uses a piecewise approach: ascending arc from launch to apex,
    descending arc from apex to landing.

    Args:
        carry: Carry distance in yards.
        apex: Maximum height in yards.
        launch_angle: Launch angle in degrees.
        descent_angle: Descent angle in degrees (positive = steep).

    Returns:
        List of (x, y) tuples, or empty list if data is insufficient.
    """
    if not all(v is not None and v > 0 for v in [carry, apex]):
        return []

    launch_rad = math.radians(launch_angle or 12)
    descent_rad = math.radians(descent_angle or 35)

    # Peak x position: estimated from launch angle steepness
    # Steeper launch = peak earlier; flatter = peak later
    peak_ratio = 0.4 + 0.2 * (1 - min(launch_rad / math.radians(20), 1))
    peak_x = carry * peak_ratio

    points = []
    half = num_points // 2

    # Ascending: quadratic from (0,0) through (peak_x, apex)
    for i in range(half + 1):
        t = i / half
        x = peak_x * t
        y = apex * (2 * t - t * t)  # Quadratic peaking at t=1
        points.append((x, y))

    # Descending: quadratic from (peak_x, apex) to (carry, 0)
    desc_dist = carry - peak_x
    for i in range(1, half + 1):
        t = i / half
        x = peak_x + desc_dist * t
        y = apex * (1 - t * t)  # Quadratic descent
        points.append((x, max(y, 0)))

    return points


def render_trajectory_view(
    df: pd.DataFrame,
    max_shots: int = 5,
    title: str = "Trajectory View",
) -> None:
    """Render 2D trajectory overlay for selected shots.

    Args:
        df: DataFrame with carry, apex, launch_angle, descent_angle columns.
        max_shots: Maximum number of trajectories to overlay.
        title: Chart title.
    """
    required = ['carry', 'apex', 'launch_angle']
    if df.empty or not all(c in df.columns for c in required):
        st.info("Trajectory data not available (need carry, apex, launch angle)")
        return

    valid = df.dropna(subset=required).head(max_shots)
    if valid.empty:
        st.info("No shots with complete trajectory data")
        return

    fig = go.Figure()
    colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd']

    for i, (_, shot) in enumerate(valid.iterrows()):
        points = compute_trajectory_points(
            carry=shot['carry'],
            apex=shot.get('apex'),
            launch_angle=shot.get('launch_angle'),
            descent_angle=shot.get('descent_angle'),
        )
        if not points:
            continue

        xs, ys = zip(*points)
        club = shot.get('club', f'Shot {i+1}')
        carry_val = shot['carry']
        fig.add_trace(go.Scatter(
            x=list(xs), y=list(ys),
            mode='lines',
            name=f"{club} ({carry_val:.0f} yds)",
            line=dict(color=colors[i % len(colors)], width=2.5),
            hovertemplate=f"{club}<br>Distance: %{{x:.0f}} yds<br>Height: %{{y:.0f}} yds<extra></extra>",
        ))

    max_carry = valid['carry'].max()
    max_apex = valid['apex'].max() if 'apex' in valid.columns else 40

    fig.update_layout(
        title=title,
        xaxis_title="Distance (yards)",
        yaxis_title="Height (yards)",
        xaxis=dict(range=[0, max_carry * 1.1]),
        yaxis=dict(range=[0, max_apex * 1.3]),
        height=400,
        showlegend=True,
        template="plotly_dark",
    )

    # Ground line
    fig.add_hline(y=0, line_color="rgba(255,255,255,0.2)", line_width=1)

    st.plotly_chart(fig, use_container_width=True)
```

**Step 4: Run tests**

Run: `python -m unittest tests.unit.test_trajectory_view -v`
Expected: PASS (2 tests)

**Step 5: Register in __init__.py and wire into Dashboard**

Add to `components/__init__.py`:

```python
from components.trajectory_view import render_trajectory_view
```

In `pages/1_ğŸ“Š_Dashboard.py`, in the `tab_shots` section, after the shot detail pane (around line 188), add:

```python
st.divider()
# Trajectory for selected shot(s)
if len(event.selection.rows) > 0:
    selected_shots = df.iloc[event.selection.rows]
    render_trajectory_view(selected_shots, max_shots=1, title="Shot Trajectory")
```

**Step 6: Run full suite**

Run: `python -m unittest discover -s tests`
Expected: All pass

**Step 7: Commit**

```bash
git add components/trajectory_view.py components/__init__.py tests/unit/test_trajectory_view.py pages/1_ğŸ“Š_Dashboard.py
git commit -m "feat: add 2D trajectory visualization component"
```

---

### Task 6: Shot-by-Shot Navigator

**Files:**
- Create: `components/shot_navigator.py`
- Modify: `components/__init__.py`
- Modify: `pages/1_ğŸ“Š_Dashboard.py`
- Test: `tests/unit/test_shot_navigator.py`

**Context:** Arrow-key navigation through individual shots within a session. Shows full metrics + mini trajectory for each shot. Replaces the table click-to-select pattern with a sequential browser.

**Step 1: Write the failing test**

Create `tests/unit/test_shot_navigator.py`:

```python
import unittest

class TestShotNavigation(unittest.TestCase):
    def test_clamp_index(self):
        from components.shot_navigator import clamp_index
        self.assertEqual(clamp_index(0, 10), 0)
        self.assertEqual(clamp_index(-1, 10), 0)
        self.assertEqual(clamp_index(10, 10), 9)
        self.assertEqual(clamp_index(5, 10), 5)

    def test_clamp_empty(self):
        from components.shot_navigator import clamp_index
        self.assertEqual(clamp_index(0, 0), 0)
```

**Step 2: Run test to verify it fails**

Run: `python -m unittest tests.unit.test_shot_navigator -v`
Expected: FAIL

**Step 3: Write the component**

Create `components/shot_navigator.py`:

```python
"""
Shot-by-shot navigator â€” browse individual shots sequentially.

Previous/Next buttons step through shots in a session. Each shot
shows full metrics and a mini trajectory.
"""
import streamlit as st
import pandas as pd
from typing import Optional


def clamp_index(idx: int, total: int) -> int:
    """Clamp index to valid range [0, total-1]."""
    if total <= 0:
        return 0
    return max(0, min(idx, total - 1))


def render_shot_navigator(
    df: pd.DataFrame,
    key_prefix: str = "shot_nav",
) -> Optional[int]:
    """Render shot navigator with prev/next buttons.

    Args:
        df: DataFrame of shots in session order.
        key_prefix: Unique key prefix for Streamlit widgets.

    Returns:
        Index of currently selected shot, or None if no data.
    """
    if df.empty:
        st.info("No shots to navigate")
        return None

    total = len(df)
    state_key = f"{key_prefix}_idx"

    # Initialize index
    if state_key not in st.session_state:
        st.session_state[state_key] = 0

    current = st.session_state[state_key]

    # Navigation row
    col_prev, col_counter, col_next = st.columns([1, 2, 1])

    with col_prev:
        if st.button("â† Prev", key=f"{key_prefix}_prev", disabled=current <= 0,
                      use_container_width=True):
            st.session_state[state_key] = clamp_index(current - 1, total)
            st.rerun()

    with col_counter:
        st.markdown(
            f"<div style='text-align:center;padding:8px;font-size:1.1em'>"
            f"Shot {current + 1} of {total}</div>",
            unsafe_allow_html=True,
        )

    with col_next:
        if st.button("Next â†’", key=f"{key_prefix}_next", disabled=current >= total - 1,
                      use_container_width=True):
            st.session_state[state_key] = clamp_index(current + 1, total)
            st.rerun()

    # Display current shot
    idx = clamp_index(st.session_state[state_key], total)
    shot = df.iloc[idx]

    club = shot.get('club', 'Unknown')
    carry = shot.get('carry', 0)
    st.markdown(f"### {club} â€” {carry:.1f} yds")

    # Metrics grid
    r1c1, r1c2, r1c3, r1c4 = st.columns(4)
    r1c1.metric("Ball Speed", f"{shot.get('ball_speed', 0):.1f} mph")
    r1c2.metric("Club Speed", f"{shot.get('club_speed', 0):.1f} mph")
    r1c3.metric("Smash", f"{shot.get('smash', 0):.2f}")
    r1c4.metric("Launch", f"{shot.get('launch_angle', 0):.1f}Â°")

    r2c1, r2c2, r2c3, r2c4 = st.columns(4)
    r2c1.metric("Face Angle", f"{shot.get('face_angle', 0):+.1f}Â°")
    r2c2.metric("Club Path", f"{shot.get('club_path', 0):+.1f}Â°")
    r2c3.metric("Back Spin", f"{int(shot.get('back_spin', 0)):,}")
    r2c4.metric("Apex", f"{shot.get('apex', 0):.0f} yds")

    return idx
```

**Step 4: Run tests**

Run: `python -m unittest tests.unit.test_shot_navigator -v`
Expected: PASS (2 tests)

**Step 5: Register and wire into Dashboard**

Add to `components/__init__.py`:

```python
from components.shot_navigator import render_shot_navigator
```

In `pages/1_ğŸ“Š_Dashboard.py`, in the `tab_shots` section, add a new sub-tab or replace the existing shot detail. After the table (line 148), add a navigator section:

```python
st.divider()
st.subheader("Shot Browser")
nav_idx = render_shot_navigator(df, key_prefix="dash_nav")
if nav_idx is not None:
    from components.trajectory_view import render_trajectory_view
    render_trajectory_view(
        df.iloc[[nav_idx]],
        max_shots=1,
        title=f"Shot {nav_idx + 1} Trajectory",
    )
```

**Step 6: Run full suite**

Run: `python -m unittest discover -s tests`
Expected: All pass

**Step 7: Commit**

```bash
git add components/shot_navigator.py components/__init__.py tests/unit/test_shot_navigator.py pages/1_ğŸ“Š_Dashboard.py
git commit -m "feat: add shot-by-shot navigator with trajectory"
```

---

### Task 7: Goal Tracking

**Files:**
- Create: `components/goal_tracker.py`
- Modify: `components/__init__.py`
- Modify: `pages/2_ğŸŒï¸_Club_Profiles.py`
- Test: `tests/unit/test_goal_tracker.py`

**Context:** Show progress toward per-club goals on Club Profiles. Goals use existing smash factor targets from `my_bag.json`. Also add carry distance goals (stored in `my_bag.json`). Display as a progress bar + trend line.

**Step 1: Write the failing test**

Create `tests/unit/test_goal_tracker.py`:

```python
import unittest

class TestGoalProgress(unittest.TestCase):
    def test_compute_progress_met(self):
        from components.goal_tracker import compute_goal_progress
        result = compute_goal_progress(current=1.50, target=1.49)
        self.assertGreaterEqual(result['percentage'], 100)
        self.assertTrue(result['met'])

    def test_compute_progress_partial(self):
        from components.goal_tracker import compute_goal_progress
        result = compute_goal_progress(current=1.40, target=1.50)
        self.assertLess(result['percentage'], 100)
        self.assertFalse(result['met'])

    def test_compute_progress_none_target(self):
        from components.goal_tracker import compute_goal_progress
        result = compute_goal_progress(current=1.40, target=None)
        self.assertIsNone(result)

    def test_compute_progress_none_current(self):
        from components.goal_tracker import compute_goal_progress
        result = compute_goal_progress(current=None, target=1.49)
        self.assertIsNone(result)
```

**Step 2: Run test to verify it fails**

Run: `python -m unittest tests.unit.test_goal_tracker -v`
Expected: FAIL

**Step 3: Write the component**

Create `components/goal_tracker.py`:

```python
"""
Goal tracking component â€” progress toward per-club targets.

Uses smash factor targets from my_bag.json. Displays progress bars
and trend direction on Club Profiles.
"""
import streamlit as st
import pandas as pd
from typing import Optional, Dict


def compute_goal_progress(
    current: Optional[float],
    target: Optional[float],
) -> Optional[Dict]:
    """Compute progress toward a numeric goal.

    Args:
        current: Current average value.
        target: Target value.

    Returns:
        Dict with 'percentage', 'met', 'current', 'target', or None if data missing.
    """
    if current is None or target is None:
        return None

    if target == 0:
        return {'percentage': 100, 'met': True, 'current': current, 'target': target}

    percentage = (current / target) * 100
    return {
        'percentage': min(percentage, 120),  # Cap at 120% for display
        'met': current >= target,
        'current': current,
        'target': target,
    }


def render_goal_tracker(
    club_name: str,
    df: pd.DataFrame,
    smash_target: Optional[float] = None,
) -> None:
    """Render goal progress for a club.

    Args:
        club_name: Club name.
        df: DataFrame of shots for this club.
        smash_target: Target smash factor from bag config.
    """
    if df.empty:
        return

    st.markdown("#### Goals & Targets")

    goals_shown = False

    # Smash factor goal
    if smash_target and 'smash' in df.columns:
        smash_avg = df['smash'].dropna().mean()
        progress = compute_goal_progress(smash_avg, smash_target)
        if progress:
            goals_shown = True
            status = "âœ…" if progress['met'] else "ğŸ¯"
            st.markdown(f"**{status} Smash Factor** â€” Target: {smash_target:.2f}")
            st.progress(min(progress['percentage'] / 100, 1.0))
            col1, col2, col3 = st.columns(3)
            col1.metric("Current Avg", f"{smash_avg:.3f}")
            col2.metric("Target", f"{smash_target:.2f}")
            gap = smash_avg - smash_target
            col3.metric("Gap", f"{gap:+.3f}")

            # Trend: compare last 20 shots vs previous 20
            smash_vals = df['smash'].dropna()
            if len(smash_vals) >= 20:
                recent = smash_vals.tail(20).mean()
                earlier = smash_vals.head(20).mean()
                trend = recent - earlier
                direction = "â†‘ Improving" if trend > 0.005 else ("â†“ Declining" if trend < -0.005 else "â†’ Steady")
                st.caption(f"Trend: {direction} ({trend:+.3f})")

    # Carry distance display (informational, no target yet)
    if 'carry' in df.columns:
        carry_avg = df['carry'].dropna().mean()
        carry_best = df['carry'].dropna().max()
        if carry_avg > 0:
            goals_shown = True
            st.markdown(f"**ğŸ“ Carry Distance**")
            col1, col2 = st.columns(2)
            col1.metric("Average", f"{carry_avg:.1f} yds")
            col2.metric("Personal Best", f"{carry_best:.1f} yds")

    if not goals_shown:
        st.info(f"No targets configured for {club_name}")
```

**Step 4: Run tests**

Run: `python -m unittest tests.unit.test_goal_tracker -v`
Expected: PASS (4 tests)

**Step 5: Register and wire into Club Profiles**

Add to `components/__init__.py`:

```python
from components.goal_tracker import render_goal_tracker
```

In `pages/2_ğŸŒï¸_Club_Profiles.py`, add import:

```python
from utils.bag_config import get_club_sort_key, get_adjacent_clubs, get_smash_target
from components.goal_tracker import render_goal_tracker
```

After the Big 3 summary section (after line 64), add:

```python
st.divider()

# â”€â”€â”€ Goals & Targets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
smash_target = get_smash_target(selected_club)
render_goal_tracker(selected_club, club_shots, smash_target=smash_target)
```

**Step 6: Run full suite**

Run: `python -m unittest discover -s tests`
Expected: All pass

**Step 7: Commit**

```bash
git add components/goal_tracker.py components/__init__.py tests/unit/test_goal_tracker.py pages/2_ğŸŒï¸_Club_Profiles.py
git commit -m "feat: add goal tracking with smash factor targets on Club Profiles"
```

---

## Final Verification

After all 7 tasks:

1. Run full test suite: `python -m unittest discover -s tests`
2. Syntax check: `python -m py_compile components/date_range_filter.py components/trajectory_view.py components/shot_navigator.py components/goal_tracker.py`
3. Manual check: `streamlit run app.py` and verify each feature

---

## Summary

| Task | Phase | Feature | New Files | Tests |
|------|-------|---------|-----------|-------|
| 1 | 5 | Smart club comparison | â€” | 4 |
| 2 | 6 | Date range filter component | `components/date_range_filter.py` | 4 |
| 3 | 6 | Wire filter to pages | â€” | 0 (manual) |
| 4 | 6 | Session notes | â€” | 2 |
| 5 | 7 | Trajectory visualization | `components/trajectory_view.py` | 2 |
| 6 | 7 | Shot-by-shot navigator | `components/shot_navigator.py` | 2 |
| 7 | 7 | Goal tracking | `components/goal_tracker.py` | 4 |
| **Total** | | | **4 new components** | **18 new tests** |
