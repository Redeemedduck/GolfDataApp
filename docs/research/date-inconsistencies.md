# Date/Time Inconsistency Analysis

**Date:** 2026-02-05
**Scope:** `sessions_discovered`, `shots`, and automation pipeline date handling
**Database:** `golf_stats.db` (1,361 shots across 27 distinct session dates)

---

## 1. Date Format Variations Found

### shots.session_date (mixed formats)

| Format | Example | Count | Source |
|--------|---------|-------|--------|
| `YYYY-MM-DD` | `2026-01-25` | 1,115 shots (82%) | `--from-listing` flow via `update_session_date_for_shots()` |
| `YYYY-MM-DDTHH:MM:SS` | `2026-01-28T00:00:00` | 246 shots (18%) | `backfill_session_dates()` or scraper's `session_date.isoformat()` |

**Root cause:** Two different code paths write `session_date` to the `shots` table using different formats:

1. **`automation_runner.py` line 506-507** (`--from-listing` flow): Calls `update_session_date_for_shots(report_id, session_date.strftime("%Y-%m-%d"))` -- produces `YYYY-MM-DD`.
2. **`golf_db.py` line 1490-1498** (`backfill_session_dates()`): Reads `session_date` directly from `sessions_discovered` and writes it as-is -- produces `YYYY-MM-DDTHH:MM:SS` because `sessions_discovered` stores ISO format from `datetime.isoformat()`.
3. **`golf_scraper.py` line 183**: Writes `session_date.isoformat()` directly into the shot data -- produces `YYYY-MM-DDTHH:MM:SS`.

### sessions_discovered.session_date (consistent ISO)

| Format | Count |
|--------|-------|
| `YYYY-MM-DDTHH:MM:SS` | 96 sessions (100% of non-NULL) |
| NULL | 22 sessions |

All values stored via `datetime.isoformat()` in `session_discovery.py` lines 294 and 309.

### shots.date_added (consistent datetime)

| Format | Example | Count |
|--------|---------|-------|
| `YYYY-MM-DD HH:MM:SS` | `2026-01-26 20:41:19` | 1,361 (100%) |

Generated by SQLite's `DEFAULT CURRENT_TIMESTAMP`. Consistent format.

### sessions_discovered.discovered_at (consistent ISO with microseconds)

| Format | Example |
|--------|---------|
| `YYYY-MM-DDTHH:MM:SS.ffffff` | `2026-01-26T07:55:34.238264` |

Generated by `datetime.utcnow().isoformat()`. Consistent format.

---

## 2. Date Source Reliability Ranking

### Distribution

| Source | Count | Percentage |
|--------|-------|-----------|
| `listing_page` | 93 sessions | 78.8% |
| `NULL` (no date) | 22 sessions | 18.6% |
| `report_page` | 2 sessions | 1.7% |
| `manual` | 1 session | 0.8% |

### Reliability Assessment

| Rank | Source | Reliability | Notes |
|------|--------|------------|-------|
| 1 | **manual** | Highest | User-confirmed date. Only 1 session uses this. |
| 2 | **listing_page** | High | Extracts from DOM date headers (e.g., "January 15, 2026"). Covers 93 sessions. Most reliable automated source. |
| 3 | **link_text** | Medium | Parsed from session link text. Not currently observed in data, but supported in code. |
| 4 | **report_page** | **UNRELIABLE** | Captures the "view date" (today's date when scraped), NOT the actual session date. See evidence below. |

### report_page Unreliability Evidence

Sessions 20842 and 20718 both have `report_page` date of `2026-02-02T00:00:00`. However, the adjacent session 20843 has a `listing_page` date of `2024-06-12T00:00:00`. Report IDs 20718 and 20842 are from mid-2024 based on the ID range. The `report_page` scraper captured the date the page was *viewed* (Feb 2, 2026), not when the session *occurred* (likely mid-2024).

---

## 3. Sessions with Missing or Incorrect Dates

### 3a. Sessions with NULL session_date in sessions_discovered (22 total)

**4 imported sessions with NULL date (have shots in database):**

| Report ID | Session Name (from backfill) | Shots | Import Date | shots.session_date |
|-----------|------------------------------|-------|-------------|-------------------|
| 43033 | Warmup - Jan 26, 2026 | 3 | 2026-01-26 | `2026-01-28T00:00:00` |
| 43032 | Drill - Jan 26, 2026 | 87 | 2026-01-26 | `2026-01-28T00:00:00` |
| 42924 | Practice - Jan 26, 2026 | 88 | 2026-01-26 | `2026-01-28T00:00:00` |
| 42719 | Practice - Jan 26, 2026 | 48 | 2026-01-26 | `2026-01-28T00:00:00` |

These 4 sessions (226 shots total) have `2026-01-28T00:00:00` in `shots.session_date`, but:
- They were **imported on Jan 26** (`date_added` = `2026-01-26`)
- Jan 28 is **two days after import** (the date is in the future relative to import)
- Their `sessions_discovered.session_date` is **NULL**
- Their session names say "Jan 26, 2026" (generated from `datetime.utcnow()` fallback during import)
- The listing page found *different* session IDs (43336-43342) for Jan 26 with `listing_page` source

**Likely cause:** These sessions were scraped with a wrong date passed from the report page (which showed Jan 28 at the time of viewing), and the listing page extraction on Feb 3 and Feb 5 did not find matching report_ids for these sessions (they may have been replaced by newer IDs on the portal).

**18 pending sessions with NULL date (no shots imported yet):**

Report IDs: 40945, 40884, 40777, 40727, 40653, 24824, 24536, 23677, 23380, 22932, 18847, 18846, 18845, 17962, 17754, 17753, 17310, 17308

These were discovered during portal navigation but never appeared on the listing page under a date header. They may be older sessions that were paginated off the listing page.

### 3b. Incorrectly Dated Sessions

| Report ID | Date Source | session_date | Likely Correct Date | Issue |
|-----------|-----------|--------------|---------------------|-------|
| 20842 | `report_page` | 2026-02-02 | ~2024-06-12 | View date captured instead of session date |
| 20718 | `report_page` | 2026-02-02 | ~2024-06-11 | View date captured instead of session date |

### 3c. Mismatched Session Names

All imported sessions have `session_name` = "Type - Jan 26, 2026" regardless of actual session date. This is because sessions were batch-imported on Jan 26, and when `item.session_date` was NULL, the code fell back to `datetime.utcnow()` for name generation (`backfill_runner.py` line 612):

```python
session_date=item.session_date or datetime.utcnow(),
```

**Affected sessions (sample):**

| Report ID | Session Name | Actual Date (listing_page) |
|-----------|-------------|---------------------------|
| 42120 | Warmup - Jan 26, 2026 | 2026-01-07 |
| 42253 | Drill - Jan 26, 2026 | 2026-01-09 |
| 42455 | Practice - Jan 26, 2026 | 2026-01-12 |
| 42646 | Practice - Jan 26, 2026 | 2026-01-15 |
| 43101 | Practice - Jan 26, 2026 | 2026-01-22 |
| 43164 | Practice - Jan 26, 2026 | 2026-01-23 |
| 43285 | Drill - Jan 26, 2026 | 2026-01-25 |

All session names claim Jan 26, but the actual session dates span from Jan 7 to Jan 25.

### 3d. Format Inconsistency in shots.session_date

The `2025-01-04T00:00:00` and `2026-01-28T00:00:00` entries use ISO format with the time component, while all other entries (1,115 shots) use date-only `YYYY-MM-DD` format. This creates issues for:
- String-based date comparisons (`WHERE session_date = '2025-01-04'` will NOT match `2025-01-04T00:00:00`)
- GROUP BY queries will treat them as separate dates
- Sorting may produce unexpected results

---

## 4. Recommendations

### R1: Standardize Date Format in shots.session_date

**Priority: HIGH**

Choose one canonical format and enforce it. Recommended: `YYYY-MM-DD` (date-only).

**Fix existing data:**
```sql
UPDATE shots
SET session_date = SUBSTR(session_date, 1, 10)
WHERE session_date LIKE '%T00:00:00';
```

**Fix code paths:**
- `golf_db.py` `backfill_session_dates()` (line 1498): Strip time component before writing:
  ```python
  date_only = session_date.replace('T00:00:00', '') if 'T' in session_date else session_date
  cursor.execute(query, (date_only, report_id))
  ```
- `golf_scraper.py` (line 183): Use `session_date.strftime('%Y-%m-%d')` instead of `session_date.isoformat()`.

### R2: Fix the 4 Sessions with Wrong Dates (226 shots)

**Priority: HIGH**

Sessions 42719, 42924, 43032, 43033 have `session_date = 2026-01-28T00:00:00` but should likely be `2026-01-26`. The session names and import timestamps both point to Jan 26.

```bash
python automation_runner.py reclassify-dates --manual 43033 2026-01-26
python automation_runner.py reclassify-dates --manual 43032 2026-01-26
python automation_runner.py reclassify-dates --manual 42924 2026-01-26
python automation_runner.py reclassify-dates --manual 42719 2026-01-26
```

### R3: Deprecate report_page as a Date Source

**Priority: HIGH**

The `report_page` source is fundamentally unreliable -- it captures the current view date, not the session date. The 2 sessions with this source (20842, 20718) both have incorrect dates (2026-02-02 instead of their actual mid-2024 dates).

- Remove or skip `report_page` as a valid date source in the priority ranking
- Clear existing `report_page` dates or mark them as unverified
- Add a warning in the `--scrape` command output

### R4: Regenerate Session Names After Date Correction

**Priority: MEDIUM**

All imported sessions have names based on the import date (Jan 26) rather than the actual session date. After correcting dates, regenerate names:

```python
# Pseudo-code for name regeneration
for session in sessions_with_listing_dates:
    correct_date = session.session_date  # from listing_page
    session_name = namer.generate_name(
        session_type=session.session_type,
        session_date=correct_date,
        clubs_used=session.clubs
    )
    discovery.update_session_name(session.report_id, session_name)
```

### R5: Fix the datetime.utcnow() Fallback

**Priority: MEDIUM**

In `backfill_runner.py` line 612, replace the `datetime.utcnow()` fallback with `None` or a clearly marked placeholder to avoid generating misleading session names:

```python
# Before (problematic):
session_date=item.session_date or datetime.utcnow(),

# After (explicit):
session_date=item.session_date,  # May be None; handle in generate_name()
```

Update `SessionNamer.generate_name()` to handle `None` dates gracefully (e.g., use "Unknown Date" or skip the date portion).

### R6: Fix COALESCE Logic for Date Updates

**Priority: MEDIUM**

The `save_discovered_session()` method in `session_discovery.py` uses `COALESCE(?, session_date)` which means a NULL new value preserves the old value. However, the comment says "Priority: listing_page > link_text > report_page" but the SQL does not actually implement priority-based replacement. A `listing_page` date should overwrite a `report_page` date.

Implement explicit priority logic:
```python
if exists:
    # Only update date if new source is higher priority
    current = conn.execute('SELECT date_source FROM sessions_discovered WHERE report_id=?', (rid,)).fetchone()
    priority = {'listing_page': 3, 'manual': 4, 'link_text': 2, 'report_page': 1, None: 0}
    if priority.get(date_source, 0) >= priority.get(current[0], 0):
        # Update date
```

### R7: Add Date Validation on Write

**Priority: LOW**

Add validation in `save_shot()` and `backfill_session_dates()`:
- Reject dates more than 1 day in the future
- Reject dates before 2020 (or the user's first session)
- Log warnings for date format mismatches

### R8: Address 18 Pending Sessions with No Dates

**Priority: LOW**

These older sessions (IDs 17308-40945) were never matched to listing page dates, likely because they are paginated beyond the visible listing page. Options:
- Accept NULL dates for historical sessions
- Use the `--manual` command for known dates
- Consider extracting dates from the session ID range (higher IDs = more recent)

---

## 5. Summary of Findings

| Category | Count | Impact |
|----------|-------|--------|
| Shots with wrong date format (`T00:00:00`) | 246 | Query/grouping errors |
| Shots with incorrect date (Jan 28 vs Jan 26) | 226 | Wrong date attribution |
| Sessions with unreliable `report_page` dates | 2 | Dates off by ~18 months |
| Sessions with misleading names (wrong date in name) | 25+ | User confusion |
| Sessions with no date at all | 22 | Missing from date-based analytics |
| Distinct date formats in shots.session_date | 2 | Inconsistent comparisons |
| Distinct date formats across all tables | 4 | Cross-table join issues |

**Overall assessment:** The date handling has multiple inconsistency vectors, but all are traceable to specific code paths. The highest-impact fix is standardizing the `session_date` format in the `shots` table and correcting the 226 shots with the wrong date.
