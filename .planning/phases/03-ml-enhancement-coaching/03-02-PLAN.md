---
phase: 03-ml-enhancement-coaching
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - ml/coaching/__init__.py
  - ml/coaching/practice_planner.py
  - ml/coaching/weakness_mapper.py
  - tests/unit/test_practice_planner.py
autonomous: true

must_haves:
  truths:
    - "User receives a structured practice plan with named drills, durations, rep counts, and instructions"
    - "Practice plans are 15-30 minutes targeting detected weaknesses from shot data"
    - "Weakness detection uses actual analytics metrics (dispersion IQR, shot shape distribution, smash factor, distance CV)"
    - "Drill library maps weakness types to specific corrective drills"
  artifacts:
    - path: "ml/coaching/practice_planner.py"
      provides: "PracticePlanner with generate_plan() returning PracticePlan with Drill list"
      contains: "class PracticePlanner"
    - path: "ml/coaching/weakness_mapper.py"
      provides: "WeaknessMapper with detect_weaknesses() returning ranked weakness dict"
      contains: "class WeaknessMapper"
    - path: "ml/coaching/__init__.py"
      provides: "Exports PracticePlanner, PracticePlan, Drill, WeaknessMapper"
    - path: "tests/unit/test_practice_planner.py"
      provides: "Tests for weakness detection, drill selection, plan generation"
  key_links:
    - from: "ml/coaching/practice_planner.py"
      to: "ml/coaching/weakness_mapper.py"
      via: "weakness detection"
      pattern: "WeaknessMapper"
    - from: "ml/coaching/weakness_mapper.py"
      to: "analytics/utils.py"
      via: "IQR filtering and distance stats"
      pattern: "filter_outliers_iqr|calculate_distance_stats"
---

<objective>
Build a structured practice plan generation system that detects weaknesses from shot data and maps them to curated drills.

Purpose: Users get actionable 15-30 minute practice plans ("Your driver carries 15 yards left; drill: alignment sticks, 20 reps") instead of vague advice (COACH-02).

Output: WeaknessMapper for analytics-based weakness detection, PracticePlanner with drill library, and tests.
</objective>

<execution_context>
@/Users/max1/.claude/get-shit-done/workflows/execute-plan.md
@/Users/max1/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@analytics/utils.py
@components/miss_tendency.py
@.planning/phases/03-ml-enhancement-coaching/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WeaknessMapper and PracticePlanner with drill library</name>
  <files>ml/coaching/__init__.py, ml/coaching/weakness_mapper.py, ml/coaching/practice_planner.py</files>
  <action>
  1. **Create `ml/coaching/__init__.py`**:
     - Export: PracticePlanner, PracticePlan, Drill, WeaknessMapper
     - All imports guarded with try/except for graceful degradation

  2. **Create `ml/coaching/weakness_mapper.py`** with class `WeaknessMapper`:
     - Import from analytics.utils: filter_outliers_iqr, calculate_distance_stats
     - Import from components.miss_tendency: _classify_shot_shape (the internal function)
     - `detect_weaknesses(self, df: pd.DataFrame, clubs: List[str] = None) -> Dict[str, float]`:
       - Returns dict of {weakness_key: severity_score (0.0-1.0)}, sorted by severity descending
       - Weakness checks (each produces a key + severity if detected):
         a) **high_dispersion**: For each club (or top 3 most-used clubs), compute side_total IQR using filter_outliers_iqr. If IQR > 15 yards, severity = min(1.0, iqr/25)
         b) **fade_pattern**: Apply _classify_shot_shape to all shots, if 'Fade' > 60%, severity = fade_pct
         c) **slice_pattern**: Same but for 'Slice' > 40%, severity = slice_pct
         d) **hook_pattern**: Same but for 'Hook' > 40%, severity = hook_pct
         e) **low_smash_factor**: If mean smash (excluding 0 and 99999 sentinels) < 1.40, severity = 1.0 - (smash / 1.45)
         f) **inconsistent_distance**: For top clubs, compute CV (std/mean) of carry. If CV > 0.08, severity = min(1.0, cv / 0.15)
         g) **high_launch**: For driver, if mean launch_angle > 16, severity = min(1.0, (la - 16) / 5)
         h) **low_launch**: For driver, if mean launch_angle < 10, severity = min(1.0, (10 - la) / 5)
       - Handle missing columns gracefully (skip check if column doesn't exist)
       - Minimum 5 shots per check; skip if fewer
       - Clean sentinel values (0, 99999) before computing

  3. **Create `ml/coaching/practice_planner.py`** with dataclasses and PracticePlanner:
     - `@dataclass Drill`: name, duration_min, focus, instructions, reps, weakness_key
     - `@dataclass PracticePlan`: duration_min, drills (List[Drill]), focus_areas (List[str]), rationale, weaknesses_addressed (Dict[str, float])
     - `class PracticePlanner`:
       - `DRILL_LIBRARY`: dict mapping weakness_key -> list of Drill objects (multiple drills per weakness for variety). Include at least 10 drills covering:
         * high_dispersion: "Alignment Stick Setup" (10min, 20 reps), "Gate Drill" (10min, 15 reps)
         * fade_pattern: "Face Control Headcover" (15min, 15 reps)
         * slice_pattern: "Inside Path Drill" (15min, 20 reps), "Strong Grip Drill" (10min, 15 reps)
         * hook_pattern: "Weak Grip Face Control" (10min, 15 reps)
         * low_smash_factor: "Impact Tape Center Contact" (10min, 20 reps), "Tee Height Drill" (10min, 15 reps)
         * inconsistent_distance: "Tempo Metronome" (15min, 15 reps), "3/4 Swing Drill" (10min, 20 reps)
         * high_launch: "Ball Position Forward" (10min, 15 reps)
         * low_launch: "Tee Height and Ball Position" (10min, 15 reps)
       - Each Drill has clear step-by-step instructions string
       - `generate_plan(self, df: pd.DataFrame, target_duration: int = 30, clubs: List[str] = None) -> PracticePlan`:
         * Create WeaknessMapper and call detect_weaknesses(df, clubs)
         * Sort weaknesses by severity descending
         * Select drills for top weaknesses that fit within target_duration (greedy fit)
         * Build rationale string citing specific detected weaknesses with numbers
         * Return PracticePlan
       - `generate_plan_from_weaknesses(self, weaknesses: Dict[str, float], target_duration: int = 30) -> PracticePlan`:
         * Same logic but takes pre-computed weaknesses (useful when LocalCoach already has them)
       - `_default_plan(self) -> PracticePlan`:
         * For when no data or no weaknesses detected
         * Returns general warm-up plan: "General Warm-up" drill + "Full Swing Practice" drill
  </action>
  <verify>
  python -c "from ml.coaching import PracticePlanner, PracticePlan, Drill, WeaknessMapper; print('Imports OK')"
  python -c "from ml.coaching.weakness_mapper import WeaknessMapper; wm = WeaknessMapper(); print('WeaknessMapper OK')"
  python -c "from ml.coaching.practice_planner import PracticePlanner; pp = PracticePlanner(); print(f'Drill library: {len(pp.DRILL_LIBRARY)} weakness types'); print('PracticePlanner OK')"
  python -m py_compile ml/coaching/__init__.py
  python -m py_compile ml/coaching/weakness_mapper.py
  python -m py_compile ml/coaching/practice_planner.py
  </verify>
  <done>
  - WeaknessMapper detects 8 weakness types from shot data using analytics utils
  - PracticePlanner has 10+ drills across 8 weakness categories
  - generate_plan() returns PracticePlan with drills, durations, and rationale
  - All files pass py_compile
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for weakness detection and practice plan generation</name>
  <files>tests/unit/test_practice_planner.py</files>
  <action>
  Create `tests/unit/test_practice_planner.py` with unittest.TestCase:

  **TestWeaknessMapper:**
  - test_empty_dataframe: returns empty dict
  - test_high_dispersion_detected: create df with 20 shots, side_total values with IQR > 15, assert 'high_dispersion' in result with severity > 0
  - test_fade_pattern_detected: create df with 20 shots, face_angle and club_path set so _classify_shot_shape returns 'Fade' for 70% of shots, assert 'fade_pattern' in result
  - test_low_smash_detected: create df with 20 shots, smash factor averaging 1.35, assert 'low_smash_factor' in result
  - test_inconsistent_distance: create df with 20 shots, high carry CV (> 0.08), assert 'inconsistent_distance' in result
  - test_min_samples_respected: create df with 3 shots (below threshold), assert no weaknesses detected
  - test_sentinel_values_cleaned: create df with some carry=99999, smash=0 values, assert they don't pollute results
  - test_missing_columns_graceful: create df without side_total or face_angle, assert no crash and appropriate weaknesses skipped

  **TestPracticePlanner:**
  - test_generate_plan_with_weaknesses: pass pre-computed weaknesses dict, verify PracticePlan has drills and duration <= target
  - test_plan_duration_within_target: generate plan with target=30, assert total drill duration <= 30
  - test_plan_prioritizes_highest_severity: provide 2 weaknesses (one 0.9, one 0.3), verify first drill addresses higher severity weakness
  - test_default_plan_when_no_data: call generate_plan with empty df, verify returns general plan (not empty)
  - test_drill_library_completeness: verify all expected weakness keys have at least one drill
  - test_plan_focus_areas_populated: generate plan, verify focus_areas list is non-empty
  - test_plan_rationale_cites_weaknesses: generate plan with known weakness, verify rationale string mentions the weakness

  Use conftest.py fixtures (ml_test_dataframe) where applicable.
  Create helper function to build synthetic shot DataFrames with specific characteristics.
  </action>
  <verify>
  python -m unittest tests.unit.test_practice_planner -v
  python -m py_compile tests/unit/test_practice_planner.py
  </verify>
  <done>
  - All tests pass (15+ test cases)
  - Coverage: weakness detection for all types, graceful degradation, plan generation, drill selection, boundary conditions
  </done>
</task>

</tasks>

<verification>
python -m py_compile ml/coaching/__init__.py ml/coaching/weakness_mapper.py ml/coaching/practice_planner.py
python -m unittest tests.unit.test_practice_planner -v
python -m unittest discover -s tests -v  # Ensure no regressions
</verification>

<success_criteria>
1. WeaknessMapper.detect_weaknesses() returns {weakness_key: severity} dict from real analytics metrics
2. PracticePlanner.generate_plan() returns PracticePlan with Drill objects, each having name, duration, reps, instructions
3. Plans are time-bounded (15-30 min target), prioritize highest-severity weaknesses
4. All new and existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-ml-enhancement-coaching/03-02-SUMMARY.md`
</output>
