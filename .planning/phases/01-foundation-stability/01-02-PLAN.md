---
phase: 01-foundation-stability
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - golf_db.py
  - utils/logging_config.py
  - components/sync_status.py
  - pages/1_Data_Import.py
  - pages/2_Dashboard.py
  - pages/3_Database_Manager.py
autonomous: true

must_haves:
  truths:
    - "Supabase sync failures are logged with structured context"
    - "User sees sync status in UI showing last sync time or pending count"
    - "Silent sync failures no longer occur"
  artifacts:
    - path: "golf_db.py"
      provides: "Structured logging for sync operations"
      contains: "logger\\.error.*sync"
      min_lines: 1500
    - path: "utils/logging_config.py"
      provides: "Logging configuration for database operations"
      exports: ["get_logger"]
    - path: "components/sync_status.py"
      provides: "Streamlit component showing sync health"
      exports: ["render_sync_status"]
      min_lines: 30
  key_links:
    - from: "golf_db.py"
      to: "utils/logging_config.py"
      via: "imports get_logger()"
      pattern: "from utils.logging_config import get_logger"
    - from: "components/sync_status.py"
      to: "golf_db.py"
      via: "calls get_sync_status()"
      pattern: "golf_db\\.get_sync_status"
---

<objective>
Replace silent `print()` error handling in Supabase sync operations with structured logging and user-visible sync status.

Purpose: Prevent data loss from silent sync failures. Give users visibility into cloud sync health and pending operations.

Output: Structured logging throughout golf_db.py, sync status component for UI, and sync health metrics function.
</objective>

<execution_context>
@/Users/max1/.claude/get-shit-done/workflows/execute-plan.md
@/Users/max1/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/PITFALLS.md

# Current implementation
@golf_db.py
@exceptions.py
</context>

<tasks>

<task type="auto">
  <name>Create logging configuration utility</name>
  <files>utils/logging_config.py</files>
  <action>
Create a new file `utils/logging_config.py` for centralized logging setup.

Implement:
1. `get_logger(name: str) -> logging.Logger` function:
   - Returns a configured logger with the given name
   - Sets log level from environment variable `GOLFDATA_LOGGING` (INFO if "1", WARNING otherwise)
   - Adds StreamHandler with structured formatter (timestamp, level, name, message)
   - Adds FileHandler to `logs/golfdata.log` (create directory if needed)

2. Log format: `%(asctime)s | %(levelname)s | %(name)s | %(message)s`

3. Ensure `utils/` directory exists and has `__init__.py`

Example usage:
```python
from utils.logging_config import get_logger
logger = get_logger(__name__)
logger.error("Sync failed", extra={"operation": "upsert", "table": "shots"})
```
  </action>
  <verify>
```bash
python -c "from utils.logging_config import get_logger; logger = get_logger('test'); logger.info('Test log')"
```
Should print log message without errors.
  </verify>
  <done>
- `utils/logging_config.py` created with `get_logger()` function
- Logger respects `GOLFDATA_LOGGING` environment variable
- Logs write to both console and `logs/golfdata.log`
  </done>
</task>

<task type="auto">
  <name>Add structured logging to golf_db.py sync operations</name>
  <files>golf_db.py</files>
  <action>
Replace all `print(f"Supabase Error: {e}")` and `print(f"SQLite Error: {e}")` with structured logging.

Changes:
1. Import logger at top: `from utils.logging_config import get_logger`
2. Create module logger: `logger = get_logger(__name__)`
3. Replace error prints with `logger.error()` calls, adding context:

For Supabase errors:
```python
except Exception as e:
    logger.error(
        f"Supabase sync failed: {e}",
        extra={
            "operation": "upsert",  # or "delete", "select"
            "table": "shots",  # or table name
            "error_type": type(e).__name__,
            "record_count": len(batch) if batch else 1,
        }
    )
    raise DatabaseError(f"Supabase sync failed", {"table": "shots", "error": str(e)})
```

For SQLite errors (keep existing behavior but add logging):
```python
except Exception as e:
    logger.error(
        f"SQLite operation failed: {e}",
        extra={"operation": "insert", "table": "shots", "error_type": type(e).__name__}
    )
    # Keep existing error handling (print or raise)
```

Update all occurrences in:
- `add_shot()` (lines ~462-470)
- `get_session_data()` (lines ~489-496)
- `delete_shot()` (sync section)
- `delete_session()` (sync section)
- `update_shot_metadata()` (sync section)

Do NOT change silent exception handling in read operations (those are intentional fallbacks).
  </action>
  <verify>
```bash
grep -n "print(f\"Supabase Error" golf_db.py
grep -n "print(f\"SQLite Error" golf_db.py
```
Both should return empty (all replaced with logger calls).
  </verify>
  <done>
- All Supabase sync operations log failures with context
- SQLite errors logged with operation details
- Exceptions include structured data (operation, table, error type)
  </done>
</task>

<task type="auto">
  <name>Add sync status tracking and UI component</name>
  <files>golf_db.py, components/sync_status.py</files>
  <action>
**In golf_db.py:**

1. Add sync status table to `init_db()` schema:
```sql
CREATE TABLE IF NOT EXISTS sync_status (
    id INTEGER PRIMARY KEY,
    last_sync_success TIMESTAMP,
    last_sync_failure TIMESTAMP,
    pending_shots INTEGER DEFAULT 0,
    pending_sessions INTEGER DEFAULT 0,
    last_error TEXT
)
```

2. Create `get_sync_status() -> dict` function:
   - Queries sync_status table (row id=1)
   - Returns dict: `{last_sync: datetime, pending_count: int, status: "synced"|"pending"|"error", last_error: str}`
   - If Supabase unavailable, return `{"status": "offline", "pending_count": 0}`

3. Update sync operations to write to sync_status table after each sync attempt:
   - Success: update `last_sync_success`, reset `pending_*` to 0
   - Failure: update `last_sync_failure`, increment `pending_*`, set `last_error`

**Create components/sync_status.py:**

Implement `render_sync_status()` Streamlit component:
1. Calls `golf_db.get_sync_status()`
2. Displays status with color-coded indicator:
   - Green "✓ Synced Xs ago" if status == "synced"
   - Yellow "⚠ N shots pending sync" if status == "pending"
   - Red "✗ Sync error: {error}" if status == "error"
   - Gray "○ Offline mode" if status == "offline"
3. Use `st.caption()` for minimal visual footprint
4. Add "Retry Sync" button if status == "error"
  </action>
  <verify>
```bash
python -c "import golf_db; golf_db.init_db(); status = golf_db.get_sync_status(); print(status)"
```
Should return sync status dict.

```bash
python -c "from components.sync_status import render_sync_status; print('Component loaded')"
```
Should load without import errors.
  </verify>
  <done>
- `sync_status` table tracks sync health metrics
- `get_sync_status()` function returns current sync state
- `render_sync_status()` component displays status in UI
- Sync operations update status table on success/failure
  </done>
</task>

<task type="auto">
  <name>Integrate sync status component into UI pages</name>
  <files>pages/2_Dashboard.py, pages/3_Database_Manager.py, pages/1_Data_Import.py</files>
  <action>
Add `render_sync_status()` component to sidebars of key pages where users monitor or modify data.

Changes:
1. Import component at top of each file: `from components.sync_status import render_sync_status`

2. **In pages/2_Dashboard.py:**
   - Add `render_sync_status()` call to sidebar after title
   - Use `st.sidebar.divider()` to separate from other sidebar content

3. **In pages/3_Database_Manager.py:**
   - Add `render_sync_status()` call to sidebar after title
   - Use `st.sidebar.divider()` to separate from other sidebar content

4. **In pages/1_Data_Import.py:**
   - Add `render_sync_status()` call to sidebar after title
   - Use `st.sidebar.divider()` to separate from other sidebar content

Placement example:
```python
st.sidebar.title("Dashboard")
render_sync_status()  # Add here
st.sidebar.divider()
# ... rest of sidebar content
```

This gives users immediate sync health visibility on all pages where data operations occur.
  </action>
  <verify>
```bash
# Check import added to all three pages
grep -l "from components.sync_status import render_sync_status" pages/1_Data_Import.py pages/2_Dashboard.py pages/3_Database_Manager.py
```
Should list all three files.

```bash
# Check render_sync_status() called in all three
grep -l "render_sync_status()" pages/1_Data_Import.py pages/2_Dashboard.py pages/3_Database_Manager.py
```
Should list all three files.
  </verify>
  <done>
- Sync status component imported in Dashboard, Database Manager, and Data Import pages
- `render_sync_status()` called in sidebar of all three pages
- Users see sync health on every data-related page
  </done>
</task>

</tasks>

<verification>
1. Check logging works: `GOLFDATA_LOGGING=1 python -c "import golf_db; golf_db.add_shot({})"`
2. Verify sync_status table exists: `sqlite3 golf_stats.db ".schema sync_status"`
3. Check component import: `python -c "from components.sync_status import render_sync_status"`
4. Verify no print() calls remain: `grep -n "print.*Supabase" golf_db.py`
5. Verify component integrated in pages: `grep -l "render_sync_status()" pages/1_Data_Import.py pages/2_Dashboard.py pages/3_Database_Manager.py`
</verification>

<success_criteria>
- All Supabase sync failures are logged with structured context
- SQLite errors are logged with operation details
- `sync_status` table tracks sync health
- `get_sync_status()` returns current sync state
- `render_sync_status()` component displays sync health in UI
- No silent sync failures occur (all errors logged)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-stability/01-02-SUMMARY.md`
</output>
